// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings for `src/clojure_compiler_bridge.h`.
///
/// Regenerate bindings with `flutter pub run ffigen --config ffigen.yaml`.
///
class ClojureCompilerBridgeBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  ClojureCompilerBridgeBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  ClojureCompilerBridgeBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  int join(
    int arg0,
  ) {
    return _join(
      arg0,
    );
  }

  late final _joinPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('join');
  late final _join = _joinPtr.asFunction<int Function(int)>();

  int replace_all(
    int str,
    int arg1,
  ) {
    return _replace_all(
      str,
      arg1,
    );
  }

  late final _replace_allPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'replace_all');
  late final _replace_all =
      _replace_allPtr.asFunction<int Function(int, int)>();

  late final ffi.Pointer<ffi.Int> _namespace = _lookup<ffi.Int>('namespace');

  int get namespace => _namespace.value;

  set namespace(int value) => _namespace.value = value;

  late final ffi.Pointer<ffi.Int32> _Token = _lookup<ffi.Int32>('Token');

  int get Token => _Token.value;

  set Token(int value) => _Token.value = value;

  late final ffi.Pointer<ffi.Int32> _TokenList =
      _lookup<ffi.Int32>('TokenList');

  int get TokenList => _TokenList.value;

  set TokenList(int value) => _TokenList.value = value;

  late final ffi.Pointer<ffi.Int32> _TokenSymbol =
      _lookup<ffi.Int32>('TokenSymbol');

  int get TokenSymbol => _TokenSymbol.value;

  set TokenSymbol(int value) => _TokenSymbol.value = value;

  late final ffi.Pointer<ffi.Int32> _TokenString =
      _lookup<ffi.Int32>('TokenString');

  int get TokenString => _TokenString.value;

  set TokenString(int value) => _TokenString.value = value;

  late final ffi.Pointer<ffi.Int32> _TokenNumber =
      _lookup<ffi.Int32>('TokenNumber');

  int get TokenNumber => _TokenNumber.value;

  set TokenNumber(int value) => _TokenNumber.value = value;

  late final ffi.Pointer<ffi.Int32> _TokenNil = _lookup<ffi.Int32>('TokenNil');

  int get TokenNil => _TokenNil.value;

  set TokenNil(int value) => _TokenNil.value = value;

  late final ffi.Pointer<ffi.Int32> _TokenTrue =
      _lookup<ffi.Int32>('TokenTrue');

  int get TokenTrue => _TokenTrue.value;

  set TokenTrue(int value) => _TokenTrue.value = value;

  late final ffi.Pointer<ffi.Int32> _TokenFalse =
      _lookup<ffi.Int32>('TokenFalse');

  int get TokenFalse => _TokenFalse.value;

  set TokenFalse(int value) => _TokenFalse.value = value;

  late final ffi.Pointer<ffi.Int32> _Reader = _lookup<ffi.Int32>('Reader');

  int get Reader => _Reader.value;

  set Reader(int value) => _Reader.value = value;

  ffi.Pointer<ffi.Int> read_form(
    int arg0,
  ) {
    return _read_form(
      arg0,
    );
  }

  late final _read_formPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int> Function(ffi.Int)>>(
          'read_form');
  late final _read_form =
      _read_formPtr.asFunction<ffi.Pointer<ffi.Int> Function(int)>();

  ffi.Pointer<ffi.Int> read_list(
    int arg0,
  ) {
    return _read_list(
      arg0,
    );
  }

  late final _read_listPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int> Function(ffi.Int)>>(
          'read_list');
  late final _read_list =
      _read_listPtr.asFunction<ffi.Pointer<ffi.Int> Function(int)>();

  ffi.Pointer<ffi.Int> read_atom(
    int arg0,
  ) {
    return _read_atom(
      arg0,
    );
  }

  late final _read_atomPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int> Function(ffi.Int)>>(
          'read_atom');
  late final _read_atom =
      _read_atomPtr.asFunction<ffi.Pointer<ffi.Int> Function(int)>();

  ffi.Pointer<ffi.Int> read_str(
    int str,
  ) {
    return _read_str(
      str,
    );
  }

  late final _read_strPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int> Function(ffi.Int)>>(
          'read_str');
  late final _read_str =
      _read_strPtr.asFunction<ffi.Pointer<ffi.Int> Function(int)>();
}

abstract class class1 {}
